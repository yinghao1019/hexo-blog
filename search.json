[{"title":"學習單元測試 - 基本觀念","url":"/unit-test-basic/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>單元測試的目的在於測試每個 class 的 function 是不是如期運轉，故撰寫目的在於測試在 A 情境 (test case) 下的<br>Input/Output 是不是如預期所想的。透過寫單元測試，也能幫助我們設計程式的撰寫習慣，避免利用一個 function 封裝全部的業務邏輯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"單元測試流程\"><a href=\"#單元測試流程\" class=\"headerlink\" title=\"單元測試流程\"></a>單元測試流程</h2><ol>\n<li>釐清對象</li>\n<li>設計測試案例 (Test case)</li>\n<li> 測試環境準備 (JUnit)</li>\n<li> 相依物件隔離 (Test Double &amp; Mockito)</li>\n<li> 測試結果 (JUnit &amp; AssertJ &amp; Mockito)</li>\n</ol>\n<h2 id=\"釐清對象與設計測試案例\"><a href=\"#釐清對象與設計測試案例\" class=\"headerlink\" title=\"釐清對象與設計測試案例\"></a>釐清對象與設計測試案例</h2><p>首先，撰寫單元測試前，需先釐清 SUT , DOC 的名詞概念意義 :</p>\n<ul>\n<li>System under test (SUT)  : 要進行功能測試的元件 (Class)</li>\n<li>Depended On Component (DOC) :  測試物件所需要用到其他功能的元件  (Class)</li>\n</ul>\n<p>因此在概念上，僅需思考 SUT 的元件是誰，以及要如何進行測試，其餘 SUT 裡面用到的 DOC 元件則是需要將它進行隔絕。 </p>\n<p>這些 DOC 元件則會在他們的單元測試中測試，只要 DOC 在自己的單元測試沒問題，那在 SUT 裡也不會有問題。</p>\n<p>找出了 SUT, 就可以開始根據 SUT 設計相對應的 <strong>測試案例 (Test Case)</strong> , 為了確保功能的完整性，需設計多個測試案例來測試功能。</p>\n<blockquote>\n<p>測試案例的準則為，只要該物件的輸入不同，結果也是不同的情況，基本上就能拆分出一個測試案例。</p>\n</blockquote>\n<p>舉例來說，代測功能中具有處理例外的情況，此時例外情況通常輸入的值會與正常時不同。<br>因此例外與正常執行的情況皆為不同的<strong>測試案例 (Test case)。</strong></p>\n<p>而 Test Case 的設計大多會 Follow 3A Pattern，如下:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethodNameReturnWhat</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"comment\">//Arrange    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//Act   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">//Assert</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>測試方法的命名方式為 test + 測試的方法 + 預期回傳值。 執行內容為測試內容的準備 (Arrange)  / 執行 (Act)  / 驗證 (Assert)。</p>\n<ul>\n<li><p>Arrange : 預先設計測試案例 的輸入資料為何，包含一些測試替身 等。</p>\n</li>\n<li><p>Act :  如何執行要測試的功能之實作部分</p>\n</li>\n<li><p>Assert: 驗證該方法輸出的資料是否符合預期 or 方始使用 DOC 的次數等等</p>\n</li>\n</ul>\n<h2 id=\"測試環境準備-JUnit\"><a href=\"#測試環境準備-JUnit\" class=\"headerlink\" title=\"測試環境準備( JUnit )\"></a>測試環境準備 (JUnit)</h2><p>當開始執行測試時，需要做的事前準備輸出報告 (測試案例成功與否) 與環境 (是否要先準備假資料，或是啟動 Web container)，<br>與當結束後是否要進行清理 (可能測試寫檔需要刪除測試產生的檔案)，這個環節 Java 通常都使用 JUnit 套件輔助撰寫，<br>在後面的系列文會有詳細的 JUnit 介紹。</p>\n<h2 id=\"相依物件隔離-Test-Double-＆-Mockito\"><a href=\"#相依物件隔離-Test-Double-＆-Mockito\" class=\"headerlink\" title=\"相依物件隔離(Test Double ＆ Mockito)\"></a>相依物件隔離 (Test Double ＆ Mockito)</h2><p>為了不讓 DOC 物件影響 SUT 測試的結果，故需要使用隔離方法來排除使用的 DOC 物件。</p>\n<p>通常隔離的概念為建立 Test Double (測試替身), 而隔離的 DOC 因為被使用的功能主要分為兩類:</p>\n<p><strong>Dummy — 取代不在乎細節的物件</strong></p>\n<p>在實作時，有些物件只會關注數量，存不存在，其物件的內容並不會影響測試案例，此時就適合使用 Dummy 物件來取代，<br>減少建立原本物件的繁瑣操作。</p>\n<p><strong>Stub — 讓 DOC 提供 SUT 想要的 Input/Output 的物件</strong><br>Stub 則是與 Dummy 不同，實作的內容會影響到測試案例的結果，為了測試程式中不同的邏輯，<br>需要讓 Stub 物件設定輸出不同的值</p>\n<p>而產生測試替身的方法主要分為三種:</p>\n<p><strong>Mock — 都是假的</strong><br>由於 Stub 物件會影響我們的測試結果，故利用 Mock 的方式來模擬，<br>故需要設定我們輸入的值以及對應預期測試情境下要輸出的值來進行替換。</p>\n<p><strong>Spy — 監控 DOC 與 SUT 的互動</strong><br>Spy 主要功能為用來檢視 Mock 與 DOC 之間的交互作用。</p>\n<p><strong>Fake — 環境有限制我只好在寫一個</strong><br>其實有 Mock 和 SPY 方法在單元測試就涵蓋了 99% 的覆蓋了，而 Fake 就是真實寫一個簡單的邏輯取代原本得邏輯<br>(Mock 和 Spy 都是直接輸出需要的值 Fake 則要寫邏輯)，舉例：Database 的使用，在單元測試使用 H2 (In-memory database)<br>，或是在內網開發環境不能使用外網時，SSL 憑證檢查工具可以寫一個 Fake，改寫成去讀隨機以準備好在 Resource 的憑證.txt</p>\n<blockquote>\n<p>以上三種建立測試替身的方法是可以同時使用的，例如對 DOC 做 Mock 再做 SPY，模擬加上監控，<br>也可以對 Fake 做 Mock 只取其中幾個邏輯做模擬，其他方法用簡單的邏輯實踐。<br>請避免搞混 Mock / Spy / Fake 的概念。</p>\n</blockquote>\n<h2 id=\"測試結果-JUnit-AssertJ-Mockito\"><a href=\"#測試結果-JUnit-AssertJ-Mockito\" class=\"headerlink\" title=\"測試結果 (JUnit / AssertJ / Mockito)\"></a>測試結果 (JUnit / AssertJ / Mockito)</h2><p>當測試環境，案例，Test double 的模擬方式都定義好了，<br>需要確認這樣的情境下所執行的結果是不是如同我們的預期，藉此來驗證有效性。</p>\n<p><strong>測試結果通常會聚焦在三點:</strong></p>\n<ol>\n<li>待測目標 (SUT) 的輸出結果是否符合預期</li>\n<li>相依物件 (DOC) 是否有符合預期的被呼叫，而呼叫次數是否準確</li>\n<li>整個 Test Case 是否有涵蓋到完整的 SUT?</li>\n</ol>\n<p>前兩點，在 Java 會透過 JUnit / AssertJ / Mockito 協助完成，<br>而第三點我們就要討論到 Unit Test 很重要的觀念，覆蓋率。</p>\n<p>覆蓋率就是單元測試執行結束後，SUT 有多少行程式碼有執行到，而執行到的程式碼 / 全部程式碼的百分比就是覆蓋率。<br>而覆蓋率也細分了一些種類，這邊只列三個基本的介紹</p>\n<ol>\n<li>Statement coverage — 程式碼每一行覆蓋</li>\n<li> Branch coverage — SUT 中的每個 if else 是不是都有進去過</li>\n<li> Condition coverage — 每個會產生 true or false 的判斷是不是都有跑到過</li>\n</ol>\n<p>Branch 和 Condition 常常會搞混，直接看個範例</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; b || b &gt; c) {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的程式碼，if 其實只要做到 a &gt; b 就可以進入，這是 Branch coverage，<br>而 Condition Coverage 則是 a &gt; b || b &gt; c 的這兩個條件都要跑到過才能算是覆蓋成功。</p>\n<p>最常用的覆蓋率工具 (IDEA/JaCoCo) 在計算覆蓋率的部分其實沒有上面如此複雜，<br>白話文就是參考以下概念進行計算：</p>\n<ol>\n<li>Class - 系統裡多少 Class 被跑到</li>\n<li> Function - Class 裡多少 Function 被跑到</li>\n<li> Line - Function 裡多少程式被跑到</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://medium.com/bucketing/java-test-1-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E7%AF%87-unit-test-c9c398c27d39\">Java Test#1 單元測試概念篇</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/search?q=%E6%B8%AC%E8%A9%A6\">菜鳥工程師 - 肉豬 - 測試</a></li>\n</ul>\n","categories":["測試"],"tags":["unit test"]}]