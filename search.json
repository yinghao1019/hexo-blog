[{"title":"單元測試基本概念","url":"/unit-test-basic/","content":"<p>單元測試的目的在於測試每個 class 的 function 是不是如期運轉，故撰寫目的在於測試在 A 情境 (test case) 下的 Input/Output 是不是如預期所想的。透過寫單元測試，也能幫助我們設計程式的撰寫習慣，避免利用一個 function 封裝全部的業務邏輯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"單元測試流程\"><a href=\"#單元測試流程\" class=\"headerlink\" title=\"單元測試流程\"></a>單元測試流程</h2><ol>\n<li>釐清對象</li>\n<li>設計測試案例 (Test case)</li>\n<li> 測試環境準備 (JUnit)</li>\n<li> 相依物件隔離 (Test Double &amp; Mockito)</li>\n<li> 測試結果 (JUnit &amp; AssertJ &amp; Mockito)</li>\n<li> 測試案例管理 (JUnit &amp; JaCoCo)</li>\n</ol>\n<h2 id=\"釐清對象與設計測試案例\"><a href=\"#釐清對象與設計測試案例\" class=\"headerlink\" title=\"釐清對象與設計測試案例\"></a>釐清對象與設計測試案例</h2><p>首先，撰寫單元測試前，需先釐清 SUT , DOC 的名詞概念意義 :</p>\n<ul>\n<li>System under test (SUT)  : 要進行功能測試的元件 (Class)</li>\n<li>Depended On Component (DOC) :  測試物件所需要用到其他功能的元件  (Class)</li>\n</ul>\n<p>因此在概念上，僅需思考 SUT 的元件是誰，以及要如何進行測試，其餘 SUT 裡面用到的 DOC 元件則是需要將它進行隔絕。 </p>\n<p>這些 DOC 元件則會在他們的單元測試中測試，只要 DOC 在自己的單元測試沒問題，那在 SUT 裡也不會有問題。</p>\n<p>找出了 SUT, 就可以開始根據 SUT 設計相對應的 <strong>測試案例 (Test Case)</strong> , 為了確保功能的完整性，需設計多個測試案例來測試功能。</p>\n<p><strong>測試案例的準則為，只要該物件的輸入不同，結果也是不同的情況，基本上就能拆分出一個測試案例。</strong></p>\n<p>舉例來說，代測功能中具有處理例外的情況，此時例外情況通常輸入的值會與正常時不同。因此例外與正常執行的情況皆為不同的<strong>測試案例 (Test case)。</strong></p>\n<p>而 Test Case 的設計大多會 Follow 3A Pattern，如下:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethodNameReturnWhat</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"comment\">//Arrange    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//Act   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">//Assert</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>測試方法的命名方式為 test + 測試的方法 + 預期回傳值。 執行內容為測試內容的準備 (Arrange)  / 執行 (Act)  / 驗證 (Assert)。</p>\n<ul>\n<li><p>Arrange : 預先設計測試案例 的輸入資料為何，包含一些測試替身 等。</p>\n</li>\n<li><p>Act :  如何執行要測試的功能之實作部分</p>\n</li>\n<li><p>Assert: 驗證該方法輸出的資料是否符合預期 or 方始使用 DOC 的次數等等</p>\n</li>\n</ul>\n<h2 id=\"測試環境準備-JUnit\"><a href=\"#測試環境準備-JUnit\" class=\"headerlink\" title=\"測試環境準備( JUnit )\"></a>測試環境準備 (JUnit)</h2><p>當開始執行測試時，需要做的事前準備輸出報告 (測試案例成功與否) 與環境 (是否要先準備假資料，或是啟動 Web container)，與當結束後是否要進行清理 (可能測試寫檔需要刪除測試產生的檔案)，這個環節 Java 通常都使用 JUnit 套件輔助撰寫，在後面的系列文會有詳細的 JUnit 介紹。</p>\n<h2 id=\"相依物件隔離-Test-Double-＆-Mockito\"><a href=\"#相依物件隔離-Test-Double-＆-Mockito\" class=\"headerlink\" title=\"相依物件隔離(Test Double ＆ Mockito)\"></a>相依物件隔離 (Test Double ＆ Mockito)</h2><p>為了不讓 DOC 物件影響 SUT 測試的結果，故需要使用隔離方法來排除使用的 DOC 物件。</p>\n<p>通常隔離的概念為 Test Double (測試替身), 而隔離的 DOC 因為被使用的功能主要分為兩類:</p>\n<p>Test Double 包含了：</p>\n<p>物件: Dummy &amp; Stub</p>\n<p>作出 Test Double 的方法: Mock &amp; Spy &amp; Fake</p>\n<h3 id=\"•-Dummy-—-取代不在乎細節的物件\"><a href=\"#•-Dummy-—-取代不在乎細節的物件\" class=\"headerlink\" title=\"• Dummy — 取代不在乎細節的物件\"></a>・Dummy — 取代不在乎細節的物件</h3><p>要被測試的方法中，如被測試的方法實作並不會呼叫 DOC 物件的方法 or 不需要 DOC 物件的資料來完成時作功能，像是只是簡單地去計算數量，則該 DOC 物件就為此類別。</p>\n<h3 id=\"•-Stub-—-讓DOC提供SUT想要的Input-Output的物件\"><a href=\"#•-Stub-—-讓DOC提供SUT想要的Input-Output的物件\" class=\"headerlink\" title=\"• Stub — 讓DOC提供SUT想要的Input/Output的物件\"></a>・Stub — 讓 DOC 提供 SUT 想要的 Input/Output 的物件</h3><p>Stub 則是 DOC 的物件內容會影像到 SUT 的 method 執行結果，即為 Stub。</p>\n<h3 id=\"•-Mock-—-都是假的\"><a href=\"#•-Mock-—-都是假的\" class=\"headerlink\" title=\"• Mock — 都是假的\"></a>・Mock — 都是假的</h3><p>由於 Stub 物件會影響我們的測試結果，故利用 Mock 的方式來模擬 DOC 物件，故需要設定我們輸入的值以及對應預期測試情境下要輸出的值來進行替換。</p>\n<h3 id=\"•-Spy-—-監控DOC與SUT的互動\"><a href=\"#•-Spy-—-監控DOC與SUT的互動\" class=\"headerlink\" title=\"• Spy — 監控DOC與SUT的互動\"></a>・Spy — 監控 DOC 與 SUT 的互動</h3><p>Spy 主要功能為用來檢視 Mock 與 DOC 之間的交互作用。</p>\n<h3 id=\"•-Fake-—-環境有限制我只好在寫一個\"><a href=\"#•-Fake-—-環境有限制我只好在寫一個\" class=\"headerlink\" title=\"• Fake — 環境有限制我只好在寫一個\"></a>・Fake — 環境有限制我只好在寫一個</h3><p>其實有 Mock 和 SPY 方法在單元測試就涵蓋了 99% 的覆蓋了，而 Fake 就是真實寫一個簡單的邏輯取代原本得邏輯 (Mock 和 Spy 都是直接輸出需要的值 Fake 則要寫邏輯)，舉例：Database 的使用，在單元測試使用 H2 (In-memory database)，或是在內網開發環境不能使用外網時，SSL 憑證檢查工具可以寫一個 Fake，改寫成去讀隨機以準備好在 Resource 的憑證.txt</p>\n<p>其實在 Wiki 上這五種都是物件，但是若是以物件的角度去看五種 Tese Double 很可能會在最後三種 Mock/Spy/Fake 搞混，因為這三種是可以重疊的，可以對 DOC 做 Mock 在做 SPY，模擬加上監控，也可以對 Fake 做 Mock 只取其中幾個邏輯做模擬，其他方法用簡單的邏輯實踐。</p>\n<h2 id=\"測試結果-JUnit-AssertJ-Mockito\"><a href=\"#測試結果-JUnit-AssertJ-Mockito\" class=\"headerlink\" title=\"測試結果 (JUnit / AssertJ / Mockito)\"></a>測試結果 (JUnit / AssertJ / Mockito)</h2><p>當測試環境，案例，Test double 的模擬方式都定義好了，需要確認這樣的情境下所執行的結果是不是如同我們的預期，藉此來驗證有效性。</p>\n<p><strong>測試結果通常會聚焦在三點:</strong></p>\n<ol>\n<li>待測目標 (SUT) 的輸出結果是否符合預期</li>\n<li>相依物件 (DOC) 是否有符合預期的被呼叫，而呼叫次數是否準確</li>\n<li>整個 Test Case 是否有涵蓋到完整的 SUT?</li>\n</ol>\n<p>前兩點，在 Java 會透過 JUnit / AssertJ / Mockito 協助完成，而第三點我們就要討論到 Unit Test 很重要的觀念，覆蓋率。</p>\n<p>覆蓋率就是單元測試執行結束後，SUT 有多少行程式碼有執行到，而執行到的程式碼 / 全部程式碼的百分比就是覆蓋率。而覆蓋率也細分了一些種類，這邊只列三個基本的介紹</p>\n<ol>\n<li>Statement coverage — 程式碼每一行覆蓋</li>\n<li> Branch coverage — SUT 中的每個 if else 是不是都有進去過</li>\n<li> Condition coverage — 每個會產生 true or false 的判斷是不是都有跑到過</li>\n</ol>\n<p>Branch 和 Condition 常常會搞混，直接看個範例</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; b || b &gt; c) {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的程式碼，if 其實只要做到 a &gt; b 就可以進入，這是 Branch coverage，而 Condition Coverage 則是 a &gt; b || b &gt; c 的這兩個條件都要跑到過才能算是覆蓋成功。</p>\n<p>最常用的覆蓋率工具 (IDEA/JaCoCo 提供的覆蓋率) 其實沒有上面如此複雜，非常單純與直觀：</p>\n<ol>\n<li>Class - 系統裡多少 Class 被跑到</li>\n<li> Function - Class 裡多少 Function 被跑到</li>\n<li> Line - Function 裡多少程式被跑到</li>\n</ol>\n<h2 id=\"測試案例管理-JUnit-JaCoCo\"><a href=\"#測試案例管理-JUnit-JaCoCo\" class=\"headerlink\" title=\"測試案例管理 (JUnit &amp; JaCoCo)\"></a><strong>測試案例管理 (JUnit &amp; JaCoCo)</strong></h2><p>前面講的都是單元測試個體，這個環節討論的是群，當系統內的單元測試個體都跑完後，觀看整個系統的覆蓋率，以及更改功能後要跑哪些相關連的單元測試都包含在此。而良好 CI/CD 流程都是建立在完善的測試案例管理，監測覆蓋率，執行單元測試群體，這裡的實做也會在後面的系列文介紹，會包含如何將單元測試分組 (跑一組單元測試裡面的個體都會執行)，與如何使用 JaCoCo 產出覆蓋率報表。</p>\n<h2 id=\"單元測試常用工具介紹\"><a href=\"#單元測試常用工具介紹\" class=\"headerlink\" title=\"單元測試常用工具介紹\"></a><strong>單元測試常用工具介紹</strong></h2><ul>\n<li>JUnit - Java 單元測試的基礎，許多操作都是建立在此之上，包含 (Unit Test 的環境建立與結果檢驗)</li>\n<li>AssertJ - 是好用的結果檢驗工具，功能比 JUnit 原生的提供的還多</li>\n<li> Mockito - Test Double 建立的好夥伴，Mockito 讓開發者不用在自己寫 Test Double 的物件</li>\n<li> JaCoCo - 覆蓋率報告產生工具</li>\n</ul>\n","categories":["測試"],"tags":["unit test"]}]