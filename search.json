[{"title":"Azure Queue Storage 介紹與操作","url":"/azure-queue/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Azure Queue Storage 適合用於儲存大量的訊息，但又不會需要長期保存時的情境，一個 Queus Storage 可以純存約百萬則訊息，</p>\n<p>存取訊息的方式支援 HTTP 與 HTTPS 。 如果要使用 Azure Queue Storage, 則需在 Azure Storage Account 中進行建立與管理。</p>\n<p><img data-src=\"https://3.bp.blogspot.com/-bykMEF0qNHA/WwqssskmT4I/AAAAAAAAgJM/2ujpeckpHlskoBXWooE-Ry5lKaEJ8OuIACLcBGAs/s640/801.jpg\" alt=\"Azure Queue\"></p>\n<br>\n\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><h3 id=\"Azure-Queue-Storage\"><a href=\"#Azure-Queue-Storage\" class=\"headerlink\" title=\"Azure Queue Storage\"></a><strong>Azure Queue Storage</strong></h3><ul>\n<li>FIFO : 先儲存的會優先被取出來處理，但由於是軟刪除，所以發生 concurrency 不一定會保持此特性</li>\n<li>每一筆訊息最大容量為 64 KB , 儲存期限為 7 天</li>\n<li>一個 queue 可容納 500TB 的資訊</li>\n<li>易於與 Azure 其他服務整合，擴張 (Azure Function)</li>\n<li> 支援 HTTP ,HTTPS 通訊協定存取</li>\n</ul>\n<h3 id=\"儲存的訊息\"><a href=\"#儲存的訊息\" class=\"headerlink\" title=\"儲存的訊息\"></a><strong>儲存的訊息</strong></h3><ul>\n<li>可以是 UTF -8 字串 或是 二進位制 (Byte Arrays) 的格式</li>\n<li> XML 文件，CSV ,TSV 檔案等</li>\n</ul>\n<br>\n\n<h2 id=\"應用時機\"><a href=\"#應用時機\" class=\"headerlink\" title=\"應用時機\"></a>應用時機</h2><p><img data-src=\"https://i.imgur.com/TjyUGl1.jpg\" alt=\"image-20240105162500590\"></p>\n<p>主要被應用在於非即時回應的非同步處理，想降低不同系統之間的耦合性，或是做為後端伺服器的系統緩衝。</p>\n<ul>\n<li>Email , SMS 的訊息發送</li>\n<li>後端 Server 紀錄 Log 資料的管道</li>\n<li>微服務系統之間的溝通橋樑</li>\n</ul>\n<br>\n\n<h2 id=\"實作介紹\"><a href=\"#實作介紹\" class=\"headerlink\" title=\"實作介紹\"></a>實作介紹</h2><p>因為筆者主要使用 Java 開發，接下來 Queue 的實作皆會已 Java 語法進行介紹常用的操作:</p>\n<ol>\n<li>Storage Account 建立 Queue</li>\n<li> 設定 Queue 連線與授權資訊</li>\n<li>傳送訊息至 Queue</li>\n<li> 取出 Queue 中的訊息</li>\n<li>更新 Queue 的訊息</li>\n<li>刪除 Queue 的訊息</li>\n<li>計算 Queue 中訊息的數量</li>\n<li> Queue 的例外處理</li>\n</ol>\n<br>\n\n<ol>\n<li> Storage Account 建立 Queue</li>\n</ol>\n<p>   登入 Azure Portal 後，選擇 Storage Account , 點選側邊欄的 Queue 後按上面的 + 進行新增</p>\n   <img data-src=\"https://i.imgur.com/gTzIb8f.png\" alt=\"azure-portal\" style=\"zoom:67%;\">\n\n<ol start=\"2\">\n<li><p>設定 Queue 連線與授權資訊</p>\n<p>設定 Queue 服務的 url 與認證方式，認證方式主要有三種 (分別為 SAS Token , Connection String , Storage Account Key) , </p>\n<p>取得認證資訊方式可參考官方文件 <a href=\"https://learn.microsoft.com/en-us/java/api/overview/azure/storage-queue-readme?view=azure-java-stable#enqueue-message-into-a-queue\">Authenticate the client</a> </p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net/%s\"</span>, ACCOUNT_NAME, queueName);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).buildClient();</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>傳送訊息至 Queue</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\"></span><br><span class=\"line\">queueClient.sendMessage(<span class=\"string\">\"myMessage\"</span>);</span><br></pre></td></tr></tbody></table></figure>\n</li>\n<li><p>取出 Queue 中的訊息</p>\n<p>取出 Queue 的 Message 有提供其他額外參數設定，由以下多做說明:</p>\n<ul>\n<li>maxMessages: 批次從 queue 中取出訊息的最大數量 。最大為 32 筆，超過設定會出現 exception </li>\n<li>visibilityTimeout: 取出後隔多少時間才能再次看到該 Message, 預設為 30 秒</li>\n<li> timeout: 與 queue 連線多久沒回應的時效限制</li>\n<li> context: 使用服務前，需要額外新增近 Http Pipeline 的資訊 </li>\n</ul>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\">queueClient.receiveMessages(<span class=\"number\">10</span>).forEach(message -&gt;</span><br><span class=\"line\">    System.out.println(message.getBody().toString()));</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>更新 Queue 的訊息</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @param messageId: Message 的Id</span></span><br><span class=\"line\"><span class=\"comment\">// @param popReceipt: 用於辨識哪個Message 要被更新</span></span><br><span class=\"line\"><span class=\"comment\">// @param visibilityTimeout: 更新後多久才能再看到</span></span><br><span class=\"line\">queueClient.updateMessage(messageId, popReceipt, <span class=\"string\">\"new message\"</span>, visibilityTimeout);</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>刪除 Queue 的訊息</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueClientBuilder</span>().endpoint(queueURL).sasToken(SAS_TOKEN).queueName(<span class=\"string\">\"myqueue\"</span>)</span><br><span class=\"line\">        .buildClient();</span><br><span class=\"line\"></span><br><span class=\"line\">queueClient.deleteMessage(messageId, popReceipt);</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>計算 Queue 中訊息的數量</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">QueueClient</span> <span class=\"variable\">queueClient</span> <span class=\"operator\">=</span></span><br><span class=\"line\">        QueueUtils.createQueueClient(queueName, QueueUtils.getDefaultConnString());</span><br><span class=\"line\">queueClient.getProperties().getApproximateMessagesCount();</span><br></pre></td></tr></tbody></table></figure>\n\n\n</li>\n<li><p>Queue 的例外處理</p>\n<p>Azure SDK 有提供額外的 Error Code 讓開發人員進行處理，詳情請見 <a href=\"https://learn.microsoft.com/en-us/rest/api/storageservices/queue-service-error-codes\">Queue Storage error codes</a></p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">queueServiceURL</span> <span class=\"operator\">=</span> String.format(<span class=\"string\">\"https://%s.queue.core.windows.net\"</span>, ACCOUNT_NAME);</span><br><span class=\"line\"><span class=\"type\">QueueServiceClient</span> <span class=\"variable\">queueServiceClient</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QueueServiceClientBuilder</span>().endpoint(queueServiceURL)</span><br><span class=\"line\">    .sasToken(SAS_TOKEN).buildClient();</span><br><span class=\"line\"><span class=\"keyword\">try</span> {</span><br><span class=\"line\">    queueServiceClient.createQueue(<span class=\"string\">\"myQueue\"</span>);</span><br><span class=\"line\">} <span class=\"keyword\">catch</span> (QueueStorageException e) {</span><br><span class=\"line\">    logger.error(<span class=\"string\">\"Failed to create a queue with error code: \"</span> + e.getErrorCode());</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></li>\n</ol>\n<br>\n\n<h2 id=\"補充說明\"><a href=\"#補充說明\" class=\"headerlink\" title=\"補充說明\"></a>補充說明</h2><p>除了 Azure Queue Storage , 微軟雲端有再推出另外一種 Queue 型態的服務 - Azure Service Bus 。相較於 Queue Storage , Service Bus 的功能與 Rabbit MQ , Kafaka , GCP PubSub  較為類似，比較偏向 Producer - Consumer 的架構，所以如果希望要較為即時的非同步處理功能，請珍惜生命，不要走錯棚！</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://dog0416.blogspot.com/2018/05/azure-azure-queue-storage.html\">Azure Queue Storage 介紹與操作</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10205084\">Azure Queue Storage 介紹 - IT 幫幫忙</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/java/api/overview/azure/storage-queue-readme?view=azure-java-stable#enqueue-message-into-a-queue\">Azure Storage Queue client library for Java</a></li>\n</ul>\n","categories":["Azure"],"tags":["Queue","Async","Azure"]},{"title":"Google Cloud Pub/Sub Console 操作","url":"/gcp-pubsub-gui/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本篇文章主要介紹如何透過 GCP 提供的 Console 介面來操作 Pub / Sub 服務，如果對 Pub/Sub 的概念還不熟悉的朋友，</p>\n<p>建議可以閱讀以下的文章進行了解.</p>\n<ol>\n<li><a href=\"/gcp-pubsub/\" title=\"Google Cloud Pub/Sub 介紹\">Google Cloud Pub/Sub 介紹</a></li>\n</ol>\n\n<h2 id=\"啟用Pub-Sub-管理功能\"><a href=\"#啟用Pub-Sub-管理功能\" class=\"headerlink\" title=\"啟用Pub/Sub 管理功能\"></a>啟用 Pub/Sub 管理功能</h2><p>按一下側邊攔，把 Pub/Sub 功能找出來</p>\n<p><img data-src=\"/\"></p>\n<h2 id=\"設定主題-Topic\"><a href=\"#設定主題-Topic\" class=\"headerlink\" title=\"設定主題 (Topic)\"></a>設定主題 (Topic)</h2><ol>\n<li><p>進入 Pub/Sub 管理頁面有，找到主題 (Topic)，選建立主題</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>設定一下主題名稱，名稱會變成一個主題 ID 提供訂閱使用 /project/ 專案名稱 /topics/ 主題名稱</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>確認一下主題生成的狀態</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>點進去 Topic 名稱後可以看狀態</p>\n<p><img data-src=\"/\"></p>\n</li>\n</ol>\n<h2 id=\"設定訂閱項目-Subscription\"><a href=\"#設定訂閱項目-Subscription\" class=\"headerlink\" title=\"設定訂閱項目 (Subscription)\"></a>設定訂閱項目 (Subscription)</h2><p>設定 Subscription 作為接受 Topic 傳遞訊息的監聽項目，本身有提供篩選機制來接收特內容的訊息。</p>\n<p>後續的其他系統整合時也是去監聽 Subscription 有無收到 Topic 傳來的資料 (Subscriber)</p>\n<ol>\n<li><p>進入 Pub/Sub 管理頁面有，找到訂閱項目 (Subscription)，選建立訂閱項目</p>\n<p><img data-src=\"/\"></p>\n</li>\n<li><p>設定訂閱項目</p>\n<ul>\n<li><p>訂閱項目名稱：會生成訂閱項目 ID <code>projects/專案名稱/subscriotions</code></p>\n</li>\n<li><p>選取 Cloud Pub/Sub 主題：選擇訂閱的 Topic 主題 (這邊就選剛剛的 Topic 做測試)</p>\n</li>\n<li><p>傳送類型:</p>\n<ul>\n<li>提取：程式去提取資料個概念</li>\n<li>推送：設定一個 https 基底的 API 提供給 subscription 在接收資料時呼叫使用，也可適用於 GCP 內部服務開出的 API (如: Cloud Run, GKE, GCS, GCE)</li>\n</ul>\n</li>\n<li><p> 訂閱項目有效期：訂閱項目的活躍保留天數 (多久沒傳遞訊息，之後會自動刪除的天數)</p>\n</li>\n<li><p>確認期限：訊息被 subscriber 捕抓或是提取後，需要多久的反應回饋時間，從提取到確認的時間差 (確認服務處理的狀態)，這邊可以作為事件被提取後，作完後續流程的確認，超過時間差就會返回到 Message Pool，提供給其他 Subscriber 提取實作。</p>\n</li>\n<li><p>訂閱項目篩選器：篩選你的訊息內容，之後才抓進來到你的 subscription 之中</p>\n<ul>\n<li><code>attributes.&lt;item-name&gt; = &lt;item-info&gt;</code></li>\n<li><code>hasPrefix(&lt;item-name&gt;, &lt;item-info&gt;)</code></li>\n</ul>\n</li>\n<li><p>訊息保留時間：訊息被發送後，到 subscription 且未被 subscriber 提取或是使用，保留在 Message Pool 的時間</p>\n</li>\n<li><p>無效信件：他會轉發你的訊息到其他的 topic 之上的設定</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://ithelp.ithome.com.tw/users/20121070/ironman/3552\">基於付費公有雲與開源機房自建私有雲之雲端應用服務測試兼叢集與機房託管服務實戰之勇者崎嶇波折且劍還掉在路上的試煉之路</a></li>\n</ul>\n","categories":["GCP"],"tags":["Async","Message Queue","GCP"]},{"title":"Google Cloud Pub/Sub 介紹","url":"/gcp-pubsub/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Cloud Pub/Sub 為 Google 推出的 message service，主要用途是讓每個獨立的應用 (Application) 間能透過 Publish-Subscribe 的模式來進行訊息交換與溝通，一般而言利用 message service<br>當作中介層 (Middleware) 來傳遞訊息，有著以下幾項優 / 缺點:</p>\n<br>\n\n<h3 id=\"優點\"><a href=\"#優點\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li>透過非同步的訊息傳遞，降低 Publisher、Subscriber 間的耦合度。意即彼此間無需知道對方位置，亦不會任意一方出現問題而導致連鎖反應。</li>\n<li>當作訊息緩衝區 (Buffer)，避免後端消化速度不夠快而無法接收新進的訊息請求。</li>\n<li>根據不同用途來訂閱 / 散佈訊息。</li>\n</ul>\n<h3 id=\"缺點\"><a href=\"#缺點\" class=\"headerlink\" title=\"缺點\"></a><strong>缺點</strong></h3><ul>\n<li><p>由於是非同步處理，因此訊息的即時性 / 順序性 / 重覆性無法受到保證。</p>\n</li>\n<li><p>需要熟悉 message service 服務的遞送流程，避免異常或訊息無法正確傳送。</p>\n<br></li>\n</ul>\n<p>就先前經驗來說，一個高可用 / 彈性的 message service，通常會考慮以下幾點:</p>\n<ul>\n<li>訊息傳遞效率</li>\n<li>可擴展性 (Scalability)、可靠性 (Reliability)、可用性 (Availability)</li>\n</ul>\n<p>為方便開發者瞭解及使用，Cloud Pub/Sub 將 AMQP (<a href=\"https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol\">Advanced Message Queuing Protocol</a>)  中 Message Broker、Exchange、Queue 等不會直接被開發者接觸的部分隱藏起來大幅降低進入門檻，開發者僅需要瞭解 Topic、Publisher、Subscriber、Push/Pull Subscription 即可撰寫相關程式。</p>\n<br>\n\n<h2 id=\"架構介紹\"><a href=\"#架構介紹\" class=\"headerlink\" title=\"架構介紹\"></a>架構介紹</h2><h3 id=\"❖主要名詞認識\"><a href=\"#❖主要名詞認識\" class=\"headerlink\" title=\"❖主要名詞認識\"></a><em><strong>❖主要名詞認識</strong></em></h3><ul>\n<li><p><strong>Message</strong>: 要傳送的 data</p>\n</li>\n<li><p><strong>Topic</strong>: 主題，是一個可以被訂閱訊息的實體</p>\n</li>\n<li><p><strong>Subscription</strong>: 訂閱，連結 Topic 跟 Subscriber 之間的實體，接收以及處理發佈訊息到 Topic</p>\n</li>\n<li><p><strong>Publisher</strong>: 發布者，提供並且發送訊息到 Topic 的單位</p>\n</li>\n<li><p><strong>Subscriber</strong>: 訂閱者， 訂閱訊息的一個單位</p>\n<br></li>\n</ul>\n<h3 id=\"❖系統流程\"><a href=\"#❖系統流程\" class=\"headerlink\" title=\"❖系統流程\"></a><strong>❖系統流程</strong></h3><p><img data-src=\"https://i.imgur.com/TsAvWUi.png\"></p>\n<p>上圖為 <a href=\"https://cloud.google.com/pubsub/docs/overview\">Google 官方</a> 介紹 Pub/Sub 的流程，主要流程如下:</p>\n<ol>\n<li>Publisher 首先在 Cloud Pub/Sub 建立傳訊息用的 Topic，然後開始向該 Topic 傳送訊息</li>\n<li>當訊息被接收前或尚未收到 Acknowledge (Ack) 時，會被保存起來並等待在次傳送出去</li>\n<li> Subscriber 向服務註冊訂閱 (Subscription) 後，所有發送到 Topic 的訊息會轉發給該 Topic 下的所有 Subscriber</li>\n<li>Subscriber 收到訊息後會回傳 Ack 訊息給 Cloud Pub/Sub，以確認訊息已經收到</li>\n<li>當 Ack 被 Cloud Pub/Sub 收到後，將該訊息自 Message Storage 刪除</li>\n</ol>\n<br>\n\n<h3 id=\"❖情境案例\"><a href=\"#❖情境案例\" class=\"headerlink\" title=\"❖情境案例\"></a><strong>❖情境案例</strong></h3><p><img data-src=\"https://i.imgur.com/7latY55.png\"></p>\n<ul>\n<li>A, B 同時可以 publish message 到相同的 Topic</li>\n<li>subcriber 可以同時接收多個 subscription 傳遞來的 Message</li>\n<li>Topic 可以有多個 subscription</li>\n</ul>\n<br>\n\n<h2 id=\"SubScription\"><a href=\"#SubScription\" class=\"headerlink\" title=\"SubScription\"></a>SubScription</h2><h3 id=\"❖操作方式\"><a href=\"#❖操作方式\" class=\"headerlink\" title=\"❖操作方式\"></a><strong>❖操作方式</strong></h3><p><strong>對訂閱者來說有兩種處理 Message 的方式，分別為 PULL 跟 PUSH.</strong></p>\n<ul>\n<li><code>[push](&lt;https://cloud.google.com/pubsub/docs/push&gt;)</code></li>\n<li>送一個 request 給 App 的 endpoint 說我要傳訊息來。</li>\n<li>以這個 endpoint return <code>[200, 201, 204, or 102]</code> 來判定為 ack, 如果不是就會一直被打直到這個訂閱所設置的最大 retention time 為止</li>\n<li>動態調整 push 的 request，根據拿到的狀態碼來調整。</li>\n<li><code>[pull](&lt;https://cloud.google.com/pubsub/docs/pull&gt;)</code></li>\n<li>視為被動的取得訂閱佇列 (subscription queue) 中的 Message</li>\n</ul>\n<p><strong>兩者機制要怎麼選用，有以下建議</strong></p>\n<ul>\n<li><code>push</code></li>\n<li>低流量情形 (&lt;10,000/second)</li>\n<li>Legacy push webhook</li>\n<li>App Engine 的訂閱者</li>\n<li><code>pull</code></li>\n<li>大量的訊息 (many more than 1/second)</li>\n<li> 效能跟訊息遞送因素很重視者</li>\n<li>公開的 Https Endpoint</li>\n</ul>\n<br>\n\n<h3 id=\"❖生命週期\"><a href=\"#❖生命週期\" class=\"headerlink\" title=\"❖生命週期\"></a><strong>❖生命週期</strong></h3><ul>\n<li>31 天內沒有被 pull or push 就會被自動刪除，或者經過手動操作被刪除</li>\n<li>訂閱的名字沒有絕對關係，用同樣的名字也會被視為兩者不同的訂閱 (情境可能是：刪除前，刪除後)</li>\n<li> 刪除後就算有大量還沒寄出的訊息，或者是 Backlog，都與新建立的無關</li>\n</ul>\n<br>\n\n<h2 id=\"注意事項\"><a href=\"#注意事項\" class=\"headerlink\" title=\"注意事項\"></a>注意事項</h2><p>使用 Cloud Pub/Sub 時需要小心以下幾點：</p>\n<ul>\n<li>若 Ack 因為意外或超時而尚未傳到 Cloud Pub/Sub 時該訊息會至多保留 7 天 (請參考 <a href=\"https://cloud.google.com/pubsub/docs/subscriber\">Retry Policy</a>)，因此程式撰寫時需考慮到訊息延遲遞送的問題，比方說加上時間戳來過濾超時的訊息。</li>\n<li>為求傳遞效能，服務不保證訊息的順序性</li>\n<li>訊息可能會發生重覆 (duplicate) 的情況，面對訊息重覆有兩種處理方式<ul>\n<li>若該請求<code>不能</code>重覆執行 (比方說銀行扣款)，就需要針對訊息夾帶的 uuid 進行重覆性確認</li>\n<li>若該請求<code>可以</code>重覆執行 (比方說查看銀行餘額)，程式便能忽略重覆性確認的流程，除非重覆次數太多導致系統性能受到影響</li>\n</ul>\n</li>\n<li>訊息在尚未接收完畢前切勿刪除該 Topic ，避免 Subscriber 無法接收其他存留的訊息</li>\n<li>建議 Subscriber 在起來時，產生其專用的 uuid 用來向服務註冊訂閱，避免名稱衝突</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://cloud.google.com/pubsub/docs/overview\">Google Pubsub 官方文件</a></li>\n<li><a href=\"https://tachingchen.com/tw/blog/google-cloud-pubsub-introduction/\">初探 Google Cloud Pub/Sub</a></li>\n<li><a href=\"https://kylinyu.win/pubsub/#-subscriber-%E6%93%8D%E4%BD%9C%E9%9D%A2\">認識 Google Cloud Pub/Sub</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10206624\">GCP 事件觸發驅動訊息推播 - Cloud Pub/Sub</a></li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10249308\">GCP 公有雲_雲端事件消息傳遞服務實戰 - Pub/Sub 組建測試之路</a></li>\n</ul>\n","categories":["GCP"],"tags":["Async","Message Queue","GCP"]},{"title":"SpringBoot i18n 國際化設定","url":"/spring-boot-i18n/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"多語系網站的好處\"><a href=\"#多語系網站的好處\" class=\"headerlink\" title=\"多語系網站的好處\"></a><strong>多語系網站的好處</strong></h3><p>在網路世界裡，使用者沒辦法親眼看到公司實際的樣子，官網就是一個形象的展現，網站有不同的語系除了更顯國際化，頁面的瀏覽上也顯得更親切；<br>對很多人來說，使用自己不熟悉的語言，會感覺陌生，容易產生不信任感。若能讓潛在客戶使用自己語言瀏覽網站，也能讓訪客覺得這家公司是一間相當有規模的公司，提高在網站上的體驗，也有機會提高轉化率。</p>\n<h3 id=\"Spring-Boot-多語系介紹-環境配置\"><a href=\"#Spring-Boot-多語系介紹-環境配置\" class=\"headerlink\" title=\"Spring Boot 多語系介紹, 環境配置\"></a>Spring Boot 多語系介紹，環境配置</h3><p>Spring Boot 自動配置 <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/MessageSource.html\">MessageSource</a> 做 i18n 多國語言訊息，不用再自己配置 <code>MessageSource</code> 的 bean 且預設會尋找 classpath 根目錄下名稱為 messages 的 properties 作為訊息來源。 如果想要使用其他名稱或路徑，可在 Spring Boot 配置檔 application.properties 設定。</p>\n<h3 id=\"套件安裝\"><a href=\"#套件安裝\" class=\"headerlink\" title=\"套件安裝\"></a>套件安裝</h3><p>springBoot 對 i18n 的支援是含在 <code>spring-context-support</code> 裡的，因此僅需引用 <em>web-starter</em>  模組，不需要再額外引用其他的 <code>xxx - starter</code></p>\n<figure class=\"highlight xml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">implementation</span> <span class=\"string\">'org.springframework.boot:spring-boot-starter-web'</span></span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"系統設定\"><a href=\"#系統設定\" class=\"headerlink\" title=\"系統設定\"></a>系統設定</h2><ol>\n<li><h3 id=\"設定Message-Source-讀取位置\"><a href=\"#設定Message-Source-讀取位置\" class=\"headerlink\" title=\"設定Message Source 讀取位置\"></a>設定 Message Source 讀取位置</h3><p>在 spring boot 中，需要在 properties 設定讀取建立的 Message 檔案路徑位置 。</p>\n<p>application.properties</p>\n<figure class=\"highlight properties\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.messages.basename</span>=<span class=\"string\">i18n/messages</span></span><br><span class=\"line\"><span class=\"attr\">spring.messages.encoding</span>=<span class=\"string\">UTF-8</span></span><br><span class=\"line\"><span class=\"attr\">spring.messages.cache-duration</span>=<span class=\"string\">3600</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>預設會是 basename 代表語系檔的路徑以及檔名，依照這裡的設定須將語系檔放在 resource/i18n 之下，且命名為 message.properties</p>\n<ul>\n<li>message_zh_TW . properties</li>\n<li>message_en_US . properties</li>\n<li>message.properties</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"https://i.imgur.com/e3HHl7o.png\"></p>\n<ol start=\"2\">\n<li><h3 id=\"設定解析器-Resolver-與攔截器-Interceptor\"><a href=\"#設定解析器-Resolver-與攔截器-Interceptor\" class=\"headerlink\" title=\"設定解析器(Resolver)與攔截器 (Interceptor)\"></a> 設定解析器 (Resolver) 與攔截器 (Interceptor)</h3><p>如果不想使用用設的 <a href=\"https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceAutoConfiguration.java\"><em>MessageSourceAutoConfiguration</em></a>  。  </p>\n<p>可以自行客製化設定解析語系名稱的清單，語系暫存的位置 以及要如何切換語系的方法</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocaleConfig</span> {</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReloadableResourceBundleMessageSource <span class=\"title function_\">messageSource</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">ReloadableResourceBundleMessageSource</span> <span class=\"variable\">messageSource</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReloadableResourceBundleMessageSource</span>();</span><br><span class=\"line\">        messageSource.setBasename(<span class=\"string\">\"classpath:i18n/messages\"</span>);</span><br><span class=\"line\">        messageSource.setDefaultEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">        messageSource.setCacheSeconds(<span class=\"number\">3600</span>); <span class=\"comment\">// Cache for an hour</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageSource;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * Spring Boot 預設採用 AcceptHeader Resolver</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocaleResolver <span class=\"title function_\">localeResolver</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 設定支援的 Locales，若 Accept-Language 沒設定或不在這清單內就會使用預設的 Locale</span></span><br><span class=\"line\">        List&lt;Locale&gt; supportedLocales = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        supportedLocales.add(Locale.TAIWAN);</span><br><span class=\"line\">        supportedLocales.add(Locale.ENGLISH);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">AcceptHeaderLocaleResolver</span> <span class=\"variable\">acceptHeaderLocaleResolver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AcceptHeaderLocaleResolver</span>();</span><br><span class=\"line\">        acceptHeaderLocaleResolver.setDefaultLocale(Locale.TAIWAN); <span class=\"comment\">// 預設 Locale</span></span><br><span class=\"line\">        acceptHeaderLocaleResolver.setSupportedLocales(supportedLocales);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acceptHeaderLocaleResolver;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 默認攔截器 客製化設定切換語系時的參數名.</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocaleChangeInterceptor <span class=\"title function_\">localeChangeInterceptor</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"type\">LocaleChangeInterceptor</span> <span class=\"variable\">lci</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocaleChangeInterceptor</span>();</span><br><span class=\"line\">        lci.setParamName(<span class=\"string\">\"lang\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lci;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span>{</span><br><span class=\"line\">        registry.addInterceptor(localeChangeInterceptor());</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<p>程式中是使用 AcceptHeaderLocaleResolver 來提取當前 Client 想用的語系，其實還有其他常見的解析方式</p>\n<table>\n<thead>\n<tr>\n<th>Locale Resolver</th>\n<th> 說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong> CookieLocaleResolver</strong></td>\n<td> 將使用者的語系偏好資料暫存於 瀏覽器的 Cookie 中</td>\n</tr>\n<tr>\n<td><strong> SessionLocaleResolver</strong></td>\n<td> 將使用者的語系偏好資料暫存於 Session 中</td>\n</tr>\n<tr>\n<td><strong> FixedLocaleResolver</strong></td>\n<td> 固定當前的語系，不會依照使用者設定的語系偏好改變，用於 Debug</td>\n</tr>\n</tbody></table>\n<br></li>\n</ol>\n<h2 id=\"讀取Locale-Message\"><a href=\"#讀取Locale-Message\" class=\"headerlink\" title=\"讀取Locale Message\"></a>讀取 Locale Message</h2><p>當設定完成後，若要在程式讀取設定的訊息，可注入 <code>MessageSource</code> 的資源，透過 key 值去對應訊息，</p>\n<p>如果後面帶入的語系不存在就會用預設的 message.properties 內容</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DemoController</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MessageSource messageSource;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(\"/{userId}\")</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus(HttpStatus.OK)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getOneUser</span><span class=\"params\">(<span class=\"meta\">@PathVariable(\"userId\")</span> Long userId)</span> <span class=\"keyword\">throws</span> Exception {</span><br><span class=\"line\">        Optional&lt;User&gt; userOption = userDao.findById(userId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (userOption.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> messageSource.getMessage(</span><br><span class=\"line\">                <span class=\"string\">\"user.controller.not.found.by.id\"</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]{userId.toString()},</span><br><span class=\"line\">                Locale.TAIWAN);</span><br><span class=\"line\">            log.error(msg);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userOption.get();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的範例是直接寫入 Locale.TAIWAN 來套用語系，實際情境下通常是透過 API 帶入語系參數來決定訊息的語系，</p>\n<p>因此可以改寫成</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @param code: 設定要取Message 的Key</span></span><br><span class=\"line\"><span class=\"comment\">// @param args: 作為變數替換Message 中的區塊</span></span><br><span class=\"line\"><span class=\"comment\">// @param Locale: 讀取Message 的語系檔</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">msg</span> <span class=\"operator\">=</span> messageSource.getMessage(<span class=\"string\">\"user.controller.not.found.by.id\"</span>,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]{userId.toString()}, LocaleContextHolder.getLocale())</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>LocaleContextHolder.getLocale()</code> 會從 request 的 header 欄位 Accept-Language 來解析語系。</p>\n<p>如果語系找不到會先抓主機的預設語系，若預設語系也不存在才會去抓 <code>message.properties</code></p>\n<h3 id=\"Message-參數化\"><a href=\"#Message-參數化\" class=\"headerlink\" title=\"Message 參數化\"></a><strong>Message 參數化</strong></h3><p>Message 支援帶入程式的變數來動態替換訊息，在訊息來源檔中的要嵌入的變數位置，將變數傳入至 <code>MessageSource.getMessage()</code> 的第二個參數做替換</p>\n<figure class=\"highlight properties\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">demo.message</span>=<span class=\"string\">MessageSource自動配置</span></span><br><span class=\"line\"><span class=\"attr\">demo.message.args</span>=<span class=\"string\">帶參數的訊息，參數0={0}, 參數1={1}</span></span><br></pre></td></tr></tbody></table></figure>\n\n<br>\n\n<h2 id=\"建立成共用元件\"><a href=\"#建立成共用元件\" class=\"headerlink\" title=\"建立成共用元件\"></a>建立成共用元件</h2><p>使用原生的語法來取 message 比較不方便，而且而且語系的參數基本上就是帶入 <code>LocaleContextHolder.getLocale()</code>。 </p>\n<p>因此將使用 <code>MessageSource</code> 的邏輯封裝成 Utils 來簡化程式碼</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocaleUtils</span> {</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MessageSource messageSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LocaleUtils</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setMessageSource</span><span class=\"params\">(MessageSource messageSource)</span> {</span><br><span class=\"line\">        LocaleUtils.messageSource = messageSource;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">get</span><span class=\"params\">(String msgKey)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleUtils.get(msgKey, (Object) <span class=\"literal\">null</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">get</span><span class=\"params\">(String msgKey, Object... args)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">try</span> {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> messageSource.getMessage(msgKey, args, getLocale());</span><br><span class=\"line\">        } <span class=\"keyword\">catch</span> (Exception e) {</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InternalServerErrorException</span>(<span class=\"string\">\"翻譯失敗:\"</span> + msgKey + <span class=\"string\">\", \"</span> + e.getMessage());</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageDTO <span class=\"title function_\">getMessage</span><span class=\"params\">(String msgKey)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleUtils.getMessage(msgKey, (Object) <span class=\"literal\">null</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MessageDTO <span class=\"title function_\">getMessage</span><span class=\"params\">(String msgKey, Object... args)</span> {</span><br><span class=\"line\">        <span class=\"type\">MessageDTO</span> <span class=\"variable\">messageDTO</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MessageDTO</span>();</span><br><span class=\"line\">        messageDTO.setMessage(LocaleUtils.get(msgKey, args, getLocale()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messageDTO;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Locale <span class=\"title function_\">getLocale</span><span class=\"params\">()</span> {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocaleContextHolder.getLocale();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://bingdoal.github.io/backend/2021/12/i18n-internationalization-in-spring-boot/\">Spring boot 的 I18n 設定與進一步包裝</a></li>\n<li><a href=\"https://www.tpisoftware.com/tpu/articleDetails/2347\">Spring Boot 快速配置多語系 (國際化)</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/2020/06/spring-boot-messagesource-i18n-example.html\">Spring Boot MessageSource i18n 範例</a></li>\n<li><a href=\"https://polinwei.com/spring-boot-i18n/\">Spring Boot 多語系設置 (i18n – 國際化)</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/2020/06/spring-boot-messagesource-auto-config.html\">Spring Boot MessageSource 自動配置</a></li>\n<li><a href=\"https://www.baeldung.com/spring-boot-internationalization\">Guide to Internationalization in Spring Boot |Baledung</a></li>\n<li><a href=\"https://reflectoring.io/spring-boot-internationalization/\">How to Internationalize a Spring Boot Application</a></li>\n<li><a href=\"https://lokalise.com/blog/spring-boot-internationalization/\">Spring Boot internationalization i18n: Step-by-step with examples</a></li>\n<li><a href=\"https://howtodoinjava.com/spring-boot/rest-i18n-example/\">Spring Boot REST: Internationalization (i18n) Example</a></li>\n</ul>\n","categories":["Spring Boot"],"tags":["Java","Spring Boot","i18n"]},{"title":"學習單元測試 - 基本觀念","url":"/unit-test-basic/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>單元測試的目的在於測試每個 class 的 function 是不是如期運轉，故撰寫目的在於測試在 A 情境 (test case) 下的<br>Input/Output 是不是如預期所想的。透過寫單元測試，也能幫助我們設計程式的撰寫習慣，避免利用一個 function 封裝全部的業務邏輯。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"單元測試流程\"><a href=\"#單元測試流程\" class=\"headerlink\" title=\"單元測試流程\"></a>單元測試流程</h2><ol>\n<li>釐清對象</li>\n<li>設計測試案例 (Test case)</li>\n<li> 測試環境準備 (JUnit)</li>\n<li> 相依物件隔離 (Test Double &amp; Mockito)</li>\n<li> 測試結果 (JUnit &amp; AssertJ &amp; Mockito)</li>\n</ol>\n<h2 id=\"釐清對象與設計測試案例\"><a href=\"#釐清對象與設計測試案例\" class=\"headerlink\" title=\"釐清對象與設計測試案例\"></a>釐清對象與設計測試案例</h2><p>首先，撰寫單元測試前，需先釐清 SUT , DOC 的名詞概念意義 :</p>\n<ul>\n<li>System under test (SUT)  : 要進行功能測試的元件 (Class)</li>\n<li>Depended On Component (DOC) :  測試物件所需要用到其他功能的元件  (Class)</li>\n</ul>\n<p>因此在概念上，僅需思考 SUT 的元件是誰，以及要如何進行測試，其餘 SUT 裡面用到的 DOC 元件則是需要將它進行隔絕。 </p>\n<p>這些 DOC 元件則會在他們的單元測試中測試，只要 DOC 在自己的單元測試沒問題，那在 SUT 裡也不會有問題。</p>\n<p>找出了 SUT, 就可以開始根據 SUT 設計相對應的 <strong>測試案例 (Test Case)</strong> , 為了確保功能的完整性，需設計多個測試案例來測試功能。</p>\n<blockquote>\n<p>測試案例的準則為，只要該物件的輸入不同，結果也是不同的情況，基本上就能拆分出一個測試案例。</p>\n</blockquote>\n<p>舉例來說，代測功能中具有處理例外的情況，此時例外情況通常輸入的值會與正常時不同。<br>因此例外與正常執行的情況皆為不同的<strong>測試案例 (Test case)。</strong></p>\n<p>而 Test Case 的設計大多會 Follow 3A Pattern，如下:</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testMethodNameReturnWhat</span><span class=\"params\">()</span></span><br><span class=\"line\">{</span><br><span class=\"line\">   <span class=\"comment\">//Arrange    </span></span><br><span class=\"line\">    </span><br><span class=\"line\">   <span class=\"comment\">//Act   </span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"comment\">//Assert</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>測試方法的命名方式為 test + 測試的方法 + 預期回傳值。 執行內容為測試內容的準備 (Arrange)  / 執行 (Act)  / 驗證 (Assert)。</p>\n<ul>\n<li><p>Arrange : 預先設計測試案例 的輸入資料為何，包含一些測試替身 等。</p>\n</li>\n<li><p>Act :  如何執行要測試的功能之實作部分</p>\n</li>\n<li><p>Assert: 驗證該方法輸出的資料是否符合預期 or 方始使用 DOC 的次數等等</p>\n</li>\n</ul>\n<h2 id=\"測試環境準備-JUnit\"><a href=\"#測試環境準備-JUnit\" class=\"headerlink\" title=\"測試環境準備( JUnit )\"></a>測試環境準備 (JUnit)</h2><p>當開始執行測試時，需要做的事前準備輸出報告 (測試案例成功與否) 與環境 (是否要先準備假資料，或是啟動 Web container)，<br>與當結束後是否要進行清理 (可能測試寫檔需要刪除測試產生的檔案)，這個環節 Java 通常都使用 JUnit 套件輔助撰寫，<br>在後面的系列文會有詳細的 JUnit 介紹。</p>\n<h2 id=\"相依物件隔離-Test-Double-＆-Mockito\"><a href=\"#相依物件隔離-Test-Double-＆-Mockito\" class=\"headerlink\" title=\"相依物件隔離(Test Double ＆ Mockito)\"></a>相依物件隔離 (Test Double ＆ Mockito)</h2><p>為了不讓 DOC 物件影響 SUT 測試的結果，故需要使用隔離方法來排除使用的 DOC 物件。</p>\n<p>通常隔離的概念為建立 Test Double (測試替身), 而隔離的 DOC 因為被使用的功能主要分為兩類:</p>\n<p><strong>Dummy — 取代不在乎細節的物件</strong></p>\n<p>在實作時，有些物件只會關注數量，存不存在，其物件的內容並不會影響測試案例，此時就適合使用 Dummy 物件來取代，<br>減少建立原本物件的繁瑣操作。</p>\n<p><strong>Stub — 讓 DOC 提供 SUT 想要的 Input/Output 的物件</strong><br>Stub 則是與 Dummy 不同，實作的內容會影響到測試案例的結果，為了測試程式中不同的邏輯，<br>需要讓 Stub 物件設定輸出不同的值</p>\n<p>而產生測試替身的方法主要分為三種:</p>\n<p><strong>Mock — 都是假的</strong><br>由於 Stub 物件會影響我們的測試結果，故利用 Mock 的方式來模擬，<br>故需要設定我們輸入的值以及對應預期測試情境下要輸出的值來進行替換。</p>\n<p><strong>Spy — 監控 DOC 與 SUT 的互動</strong><br>Spy 主要功能為用來檢視 Mock 與 DOC 之間的交互作用。</p>\n<p><strong>Fake — 環境有限制我只好在寫一個</strong><br>其實有 Mock 和 SPY 方法在單元測試就涵蓋了 99% 的覆蓋了，而 Fake 就是真實寫一個簡單的邏輯取代原本得邏輯<br>(Mock 和 Spy 都是直接輸出需要的值 Fake 則要寫邏輯)，舉例：Database 的使用，在單元測試使用 H2 (In-memory database)<br>，或是在內網開發環境不能使用外網時，SSL 憑證檢查工具可以寫一個 Fake，改寫成去讀隨機以準備好在 Resource 的憑證.txt</p>\n<blockquote>\n<p>以上三種建立測試替身的方法是可以同時使用的，例如對 DOC 做 Mock 再做 SPY，模擬加上監控，<br>也可以對 Fake 做 Mock 只取其中幾個邏輯做模擬，其他方法用簡單的邏輯實踐。<br>請避免搞混 Mock / Spy / Fake 的概念。</p>\n</blockquote>\n<h2 id=\"測試結果-JUnit-AssertJ-Mockito\"><a href=\"#測試結果-JUnit-AssertJ-Mockito\" class=\"headerlink\" title=\"測試結果 (JUnit / AssertJ / Mockito)\"></a>測試結果 (JUnit / AssertJ / Mockito)</h2><p>當測試環境，案例，Test double 的模擬方式都定義好了，<br>需要確認這樣的情境下所執行的結果是不是如同我們的預期，藉此來驗證有效性。</p>\n<p><strong>測試結果通常會聚焦在三點:</strong></p>\n<ol>\n<li>待測目標 (SUT) 的輸出結果是否符合預期</li>\n<li>相依物件 (DOC) 是否有符合預期的被呼叫，而呼叫次數是否準確</li>\n<li>整個 Test Case 是否有涵蓋到完整的 SUT?</li>\n</ol>\n<p>前兩點，在 Java 會透過 JUnit / AssertJ / Mockito 協助完成，<br>而第三點我們就要討論到 Unit Test 很重要的觀念，覆蓋率。</p>\n<p>覆蓋率就是單元測試執行結束後，SUT 有多少行程式碼有執行到，而執行到的程式碼 / 全部程式碼的百分比就是覆蓋率。<br>而覆蓋率也細分了一些種類，這邊只列三個基本的介紹</p>\n<ol>\n<li>Statement coverage — 程式碼每一行覆蓋</li>\n<li> Branch coverage — SUT 中的每個 if else 是不是都有進去過</li>\n<li> Condition coverage — 每個會產生 true or false 的判斷是不是都有跑到過</li>\n</ol>\n<p>Branch 和 Condition 常常會搞混，直接看個範例</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &gt; b || b &gt; c) {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">} <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>上面的程式碼，if 其實只要做到 a &gt; b 就可以進入，這是 Branch coverage，<br>而 Condition Coverage 則是 a &gt; b || b &gt; c 的這兩個條件都要跑到過才能算是覆蓋成功。</p>\n<p>最常用的覆蓋率工具 (IDEA/JaCoCo) 在計算覆蓋率的部分其實沒有上面如此複雜，<br>白話文就是參考以下概念進行計算：</p>\n<ol>\n<li>Class - 系統裡多少 Class 被跑到</li>\n<li> Function - Class 裡多少 Function 被跑到</li>\n<li> Line - Function 裡多少程式被跑到</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><a href=\"https://medium.com/bucketing/java-test-1-%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6%E6%A6%82%E5%BF%B5%E7%AF%87-unit-test-c9c398c27d39\">Java Test#1 單元測試概念篇</a></li>\n<li><a href=\"https://matthung0807.blogspot.com/search?q=%E6%B8%AC%E8%A9%A6\">菜鳥工程師 - 肉豬 - 測試</a></li>\n</ul>\n","categories":["Test"],"tags":["Unit Test"]}]